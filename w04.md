---
permalink: /W04/
---

[HOME](../)

# Top 10 List of Week 04

1. [Memory](https://en.wikipedia.org/wiki/Computer_memory)   
Memory consists of a large array of bytes, each with its own address. The CPU fetches instructions from memory according
to the value of the program counter. Main memory and the registers buily into each processing core are the only general-purpose
storage that the CPU can access directly. Registers that are built into each CPU core are generally accessible within one cycle
of the CPU clock, hence making it faster. Unlike registers, main memory is accessed via a transaction on the memory bus. Completing
a memory access may take many cycles of the CPU clock.

2. [Binding Address](https://www.techwalla.com/articles/the-advantages-disadvantages-of-isolated-input-output-memory)  
Address binding is the process of mapping from one address space to another address space. An address binding can be done in 3 different ways:
- Compile time (If you know that during compile time where process will reside in memory then absolute address is generated)
- Load time (If it is not known at the compile time where process will reside then relocatable address will be generated. Loader translates the relocatable address to absolute address.)
- Execution time (The instructions are in memory and are being processed by the CPU. )

3. [Logical vs Physical](https://www.geeksforgeeks.org/logical-and-physical-address-in-operating-system/?ref=lbp) 
An address generated by the CPU is commonly reffered to as a logical address, whereas an address seen by the memory unit,the one 
loaded into the memory-address register of the memory, is commonly referred to as a physical address/virtual address.
The set of all logical addresses generated by a program is a logical address space The set of all physical addresses corresponding 
to these logical addresses is a physical address space.
Thus, in the execution-time address-binding scheme, the logical and physical address spaces differ.
The run-time mapping from vitual to physical addresses is done by a hardware device called the memory-management unit(MMU)

4. Dynamic Loading & Linking  
- To obtain better memory-space utilization, we can use dynamic loading. With dynamic loading, a routine is not loaded until it is called/needed.
This method is useful when large amounts of code are needed to handle infrequently occuring cases, such as error routines. In such
a situation, atlhough the total program size may be large, the portion that is used and loaded may be much smaller.
- [Dynamically linked libraries (DLLs)](https://en.wikipedia.org/wiki/Dynamic-link_library) or shared libraries are system libraries that are linked to user programs only when the programs are run.
Without this facility, each program on a system must include a copy of its language library. This requirement increases the size of an executable 
image, but also waste main memory.

5. [Contiguous Memory Allocation](https://www.geeksforgeeks.org/difference-between-contiguous-and-noncontiguous-memory-allocation/?ref=lbp)  
The main memory has the responsibility to accomodate the OS and userspace. We therefore need to alocate it efficiently.
In Contiguous memory allocation,when the process arrives from the ready queue to the main memory for execution, the contiguous memory blocks are 
allocated to the process according to its requirement. Now, to allocate the contiguous space to user processes, the memory can be divide either in:
-Fixed-sized partition : the memory is divided into fixed-sized blocks and each block contains exactly one process
-Variable-sized partition : the OS maintains a table that contains the information about all memory parts that are occupied and available for the processes.

6. A system uses different algorithms to allocate memory from the main memory segment. These algorithms are also known as the memory partitioning algorithms
 are broadly categorized under the following algorithms:
- First fit : In the first fit approach is to allocate the first free partition or hole large enough which can accommodate the process. It finishes after finding the first suitable free partition.
- Best fit : The best fit deals with allocating the smallest free partition which meets the requirement of the requesting process. This algorithm first searches the entire list of free partitions 
and considers the smallest hole that is adequate. It then tries to find a hole which is close to actual process size needed.
- Worst fit : In worst fit approach is to locate largest available free portion so that the portion left will be big enough to be useful. It is the reverse of best fit.
Both first fit and best fit are better than worst fit in terms of decreasing time and storage utilization. Neither first fit nor best fit is clearly better 
than the other in terms of storage utiization, but firs fit is generally faster. 

7. [Paging](https://www.guru99.com/paging-in-operating-system.html)  
Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. This scheme permits the physical address space of 
a process to be nonâ€“contiguous.
Address generated by CPU is divided into:
- Page number(p): Number of bits required to represent the pages in Logical Address Space or Page number
- Page offset(d): Number of bits required to represent particular word in a page or page size of Logical Address Space or word number of a page or page offset.

Physical Address is divided into:
- Frame number(f): Number of bits required to represent the frame of Physical Address Space or Frame number.
- Frame offset(d): Number of bits required to represent particular word in a frame or frame size of Physical Address Space or word number of a frame or frame offset.  

Steps taken by the MMU to translate a logical addres to physical address:
- Extract p and use it as an index to the page table  
- Extract corresponding f from the page table  
- Replace p in the logical address with f
